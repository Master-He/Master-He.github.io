
# 前言

参考代码
https://gitee.com/moxi159753/LearningNotes/tree/master/JVM/Code



# 1. JVM和Java体系结构



![img](JVM宋红康.assets/617677b107912943ddf963f5)



方法区的具体实现有永久代和元空间

JDK1-7（永久代）， JDK8 （元空间） 

反编译

javap -v Main.class



# 2. 类加载子系统

## 1. 加载

加载class文件的方式

1. 从本地系统中直接加载
2. 通过网络获取， 典型场景： Web Applet
3. 从zip压缩包中读取， 成为日后jar, war格式的基础
4. 运行时计算生成， 使用最多的是： 动态代理技术
5. 由其他文件生成， 典型场景：JSP应用
6. 从专有数据库中提取.class文件，比较少见
7. 从加密文件中获取， 典型的防class文件被反编译的保护措施



看.class文件的软件 Binary Viewer（IDEA也有插件： jclasslib Bytecode viewer）



## 2. 链接

1. 验证
    1. 包含文件格式验证，元数据验证，字节码验证，符号引用验证
2. 准备
    1. 赋值默认初始值， 基本类型，int赋值为0， bollean赋值为false
    2. 这里不包含final修饰的static, 因为final在编译的时候就会分配，准备阶段会显式初始化
3. 解析
    1. 将常量池内的符号引用转换为直接引用
    2. 事实上，解析操作往往会伴随JVM在执行初始化后再执行
    3. 符号引用就是一组符号，用来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。 直接引用就是直接执行目标的指针，相对偏移量或一个间接定位到目标的句柄。
    4. 解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Methodref_info、CONSTANT_Fieldref_info.



## 3. 初始化

1. 初始化阶段就是执行类构造器方法\<clinit\>()的过程。
2. 此方法不需定义，是javac编译器自动收集类中的所有<u>**类变量的赋值动作**</u>和<u>**静态代码块**</u>中的语句合并起来的。
3. 构造器方法中指令按语句在源文件中出现的顺序执行。
4. **\<clinit\>()<u>不同于类的构造器</u>。**（关联：构造器是虚拟机视角下的\<init\>()）。
5. 若该类具有父类,JVM会保证子类\<clinit\>()执行前，父类的\<clinit\>()已经执行完毕。
6. 虚拟机必须保证一个类的\<clinit\>()方法在多线程下被同步加锁。（工作中遇到过！！！）
    1. 实际案例： https://www.cnblogs.com/myseries/p/12899428.html
    2. classloader在初始化一个类的时候，会对当前类加锁，加锁后，再执行类的静态初始化块。
        1. 线程1：类A对class A加锁，加锁后，执行类的静态初始化块（在堆栈里体现为\<clinit\>函数），发现用到了class B，于是去加载B；
        2. 线程2：类B对class B加锁，加锁后，执行类的静态初始化块（在堆栈里体现为\<clinit\>函数），发现用到了class A，于是去加载A；
        3. 死锁发生。因为 jvm 内部加了锁，所以jstack -l 不会显示死锁的发生
    3. **如何解决类加载出现的死锁问题？**
        1. 可以显式在主线程最开始用forName加载这些类的，这样类加载就变成在main线程中串行加载，问题得到解决
            1. Class.forName("com.**.**.A");
            2. Class.forName("com.**.**.B");

 

## 类加载器分类

启动类加载器、扩展类加载器、应用类加载器

https://zhuanlan.zhihu.com/p/73359363

类的加载路径

```java
URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
for (URL url : urls) {
    System.out.println(url);
}

URL[] urls = ((URLClassLoader) ClassLoader.getSystemClassLoader().getParent()).getURLs();
for (URL url : urls) {
    System.out.println(url);
}

```



启动类加载器：

1. 这个类是C/C++实现的，嵌套在JVM内部
2. 加载核心类库
3. 并不是继承java.lang.ClassLoader， 没有父类加载器
4. 加载扩展类和应用类加载器，并指定为他们的父类加载器
5. 处于安全考虑，Bootstrap启动类加载器只加载包名为java, javax, sun等开头的类



扩展类加载器

​	1. 在jre/lib/ext下加载类库， 如果用户创建的jar放在扩展类加载器的加载路劲下， 也会自动由扩展类加载器加载



应用程序类加载器

	1. 它负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库
	2. 该类加载器是程序中默认的类加载器





自定义类加载器

除了启动类加载器，其他都是自定义类加载器。 



为什么要自定义类加载器

1. 隔离加载类
    1. tomcat部署多个web应用时，就需要隔离。热部署卸载各自的类
2. 修改类加载的方式
3. 扩展加载源
4. 防止源码泄露





## 双亲委派机制

按个人理解: 就是类加载器收到加载请求的时候，它不是自己先去加载，而是向上委托给父级类加载器，这个过程直到启动类加载器。然后如果父级类加载器加载失败，则由子类加载器加载。如果所有的子类加载器都加载不成功，则抛出异常。



优点

1. 避免类的重复加载
2. 保证核心类库的安全（沙箱安全机制）

缺点

​	1. 顶层的 ClassLoader无法访问底层的ClassLoader所加载的类



## 其他

类加载器的引用（不太理解）

​	JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的。那么JVM会**将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的



Java程序对类的使用方式分为： **主动使用和被动使用**

1. 主动使用，又分为七种情况：
    1. 创建类的实例
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射（比如Class.forName("org.example.Test)）
    5. 初始化一个类的子类
    6. Java虚拟机启动时被标明为启动类的类
    7. JDK7开始提供的动态语言支持： java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化
2. 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化（调用\<clinit\>()方法）







# 3. 运行时数据区



线程独有：程序计数器，java虚拟机栈， 本地方法栈

线程共享：堆，堆外内存（方法区，代码缓存（JIT产生的））

 

一个JVM对应一个Runtime类



线程

在hotspot jvm里面， 每个线程都与操作系统的本地线程直接映射。

操作系统负责所有线程的安排调度到任何一个可用的cpu上，一旦本地线程初始化成功，它就会调用java线程中的run()方法



# 4. PC寄存器(程序计数器)

pc寄存器是逻辑意义上的寄存器，而不是物理意义上的，它是一块很小的内存空间。

pc寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，由执行引擎读取下一条指令。

每个线程都有它自己的程序计数器，是线程私有的

任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）



# 5. 虚拟机栈

Java 的指令是根据栈来设计的，不同的平台CPU架构不同， 所以不能设计为基于寄存器的

**优点： 跨平台，指令集小，编译器容易实现**

**缺点： 性能下降，实现同样的功能需要更多的指令**



栈是运行时的单位，堆是存储时的单位 



Java虚拟机栈管理Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回



## 常见异常

开发中遇到常见的异常？

StackOverflowError(递归没有处理好终止条件，就会出现的异常)

OutofMemoryError



我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定函数调用的最大可达深度。

 默认线程的栈大小是1024kb,  设置栈内存大小` -Xss2048k`



## 栈中存储的是什么

栈中的数据都是以栈帧（Stack Frame）的格式存在

一个方法对应这一个栈帧，栈顶的方法就是当前方法。栈帧和方法是一一对应的关系 Debug调试的时候展示的就是Java虚拟机栈

栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

执行引擎运行的所有字节码指令只指针当前栈帧进行操作

如果在一个方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端，成为新的当前帧。

当前方法结束后（return结束或者抛异常结束），栈顶的栈帧被丢弃。



## 栈帧的内部结构

1. **局部变量表**（8种基本数据类型，对象的引用地址）
2. **操作数栈（表达式栈）**
3. 动态链接 （指向**运行时常量池**的方法引用）（运行时常量池是方法区的东西）
4. 方法返回地址（方法正常退出或异常退出的定义）
5. 一些附加信息





### 局部变量表

局部变量表，又叫本地变量表，局部变量数组

定义一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量。这些数据类型包含8中基本数据类型，对象引用，retrunAddress类型  

**局部变量表存储的基本单元是Slot(变量槽)**，32位以内的类型只占用一个slot(包括returnAddress类型，byte，short, char在存储前被转换为int) ，64位的类型（long和double）占用两个slot。

由于局部变量是线程独有的，故不存在数据安全问题

局部变量表所需的容量大小都是在编译期就确定下来的。并保存在方法的Code属性的maximum local variables数据项中（借助IDEA插件jclasslib bytecode viewer查看）。在方法运行期间是不会改变局部变量表的大小的。



### 操作数栈

操作数栈，<u>**主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间**</u>

操作数栈就是**<u>JVM执行引擎的一个工作区</u>**，当一个方法刚开始执行的时候，一个新的栈帧也就会被创建出来。

每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中， 为max_stack的值。

栈中的任何一个元素都可以是任意的Java数据类型

- 32bit的类型占用一个栈单位深度
- 64bit的类型占用两个栈单位深度

操作数栈并非才用访问索引的方式来进行数据访问的，而是通过标准的入栈和出栈操作来完成一次数据访问

![image-20220904233204996](JVM宋红康.assets/image-20220904233204996.png)



由于操作数是存储在内存中的，因此频发地执行内存读/写操作，必然会影响执行速度，为了解决这个问题，hotspot jvm的设计者们提出了栈顶缓存技术（Tos Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率





### 动态链接

指向运行时常量池的方法引用

作用： 描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用



为什么需要常量池？

常量池的作用就是为了提供一些符号和常量，便于指令的识别



### 方法调用

**方法调用**

在jvm中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关



**静态链接**

在一个字节码文件被装载JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。（早期绑定）



**动态链接**

如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用的转换过程具备动态性，因为也就被称之为动态链接。（晚期绑定）



**非虚方法**

如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。

静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法（不涉及多态，即方法不能重写）

其他方法称为**虚方法**



**方法调用指令**

invokespecial（非虚方法）

invokestatic（非虚方法）

invokevirtual（虚方法）

invokeingerface（接口）

invokedynamic （lambda表达式）



**虚方法表**

在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重写在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此，为了调高性能，JVM采用在类的方法区建立一个虚方法表来实现。

每个类中都有一个虚方法表，表中存放这各个方法的实际入口

那么虚方法表什么时候被创建？

需方发表在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。



### 方法返回地址

存放调用该方法的pc寄存器的值  

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。

方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。

而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息

  

### 一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息



## 虚拟机栈的5道面试题

1. 举例栈溢出的情况？（Stack Overflow Error）
    1. 通过-Xss设置栈的大小； OOM
2. 调整栈大小，就能保证不出现溢出吗？
    1. 不能， 比如递归方法没有设置好结束条件
3. 分配的栈内存越大越好？
    1. 不是，会占用其他内存空间
4. 垃圾回收是否会涉及到虚拟机栈？
    1. 不会
5. 方法中定义的局部变量是否线程安全？
    1. 是的，因为是线程独有





# 6. 本地方法接口

就是Java调用非java代码的接口

其他语言也有类似的东西， 比如在C++中，你可以用extern "C" 告诉C++编译期去调用一个C的函数



# 7. 本地方法栈

Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用

native关键字 用来 登记本地方法

在hotspot jvm中，直接将本地方法栈和虚拟机合二为一。



# 8. 堆

## 1. 堆的核心概述

一个JVM实例进程只存在一个堆内存，堆也是Java内存管理的核心区域

Java堆区在JVM启动的时候即被床架，其空间大小也就确定了。是JVM管理的最大一块内存空间

堆内存的大小是可以调节的

堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

所有线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB）



了解： C:\Program Files\Java\jdk1.8.0_311\bin有一个exe叫jvisualvm.exe



堆空间细分

1. 新生区
    1. Eden区
    2. Survivor区（大小只算其中一个区，因为同一时间只有一个区有数据）
        1. 0区
        2. 1区
2. 养老区
3. 元空间（永久区，Java8之后不属于堆空间，而是属于方法区）



## 2.  设置堆内存大小和OOM

设置最小和最大值范围

-Xms10M (等价于-XX:InitalHeapSize， 单位不区分大小写  )

-Xmx10M (等价于-XX:MaxHeapSize)



通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完**堆区后不需要重新分隔计算堆区的大小**，从而提供性能（换句话说初始内存和最大内存一样，就减少了从初始内存到最大内存的扩容操作）

默认情况下,初始内存大小：物理内存大小/64, 最大内存大小：物理内存大小/4 



**查看内存使用情况**

jstat -gc [pid]

**打印垃圾回收细节**

-XX:+PrintGCDetails



 



## 3. 年轻代和老年代

1. 年轻代
    1. Eden区
    2. Survivor区（大小只算其中一个区，因为同一时间只有一个区有数据）
        1. 0区， 也叫from区
        2. 1区， 也叫to区
2. 老年代



配置新生代与老年代在堆结构的占比

默认-XX:NewRatio=2, 表示 新生代占1，老年代占2，新生代占整个堆的1/3

可以修改-XX:NewRatio=4, 表示新生代占1，老年代占4， 新生代占整个堆的1/5



配置Eden空间和另外两个Survivor的空间占比

	默认比值是8:1:1

设置方法 -XX:SurvivorRatio=8

几乎所有的java对象都是在Eden区被new出来的， 绝大部分的Java对象的销毁都在新生代进行了



查看运行进程NewRatio比例

```shell
jnifo -flag NewRatio [pid]
jinfo -flag MaxHeapSize [pid]
```



查看运行进程gc

```shel
jstat -gc [pid]
```



关闭自适应的内存分配策略

```shell
-XX:-UseAdaptiveSizePolicy   # “-”号表示关闭， “+”号表示开启
```



java jvm参数设置大全

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

http://www.51gjie.com/java/551.html





## 4. 图解对象分配过程

啥时候能进养老区？ 可设置次数，默认是15次

-XX:MaxTenuringThreshold=threshold



为什么有两个幸存者区？ 

**因为需要整理碎片化内存**



总结：

1. 针对幸存者s0,s1区的总结： 复制之后有交换，谁空谁是to
2. 关于垃圾回收： 频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集


伊甸园区满了， MinorGC会执行，会同时清理Eden和Survivor区
幸存者去满了，并不会触发MinorGC


常见的调优工具
1.  jdk命令行
	1. jmap
	2. jinfo
	3. jstat
	4. javap
2. Eclipse： Memory Analyzer Tool  (MAT)
3. jconsole
4. jprofiler
5. java filght recorder
6. gcviewer
7. gc easy




## 5. Minor GC、 Major GC 、Full GC

伊甸园区满了， MinorGC（完全等同于YoungGC）会执行，会同时清理Eden和Survivor区
养老区满了，MajorGC 会执行。
FullGC 收集整个方法区和java堆的垃圾回收

针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型： 一种是部分收集（Partial GC）, 一种是整堆收集（Full GC）
1. 部分收集
	1. Minor GC/ Young GC 只是新生代（Eden,s0,s1）的垃圾收集
	2. Major GC/ Old GC 只是老年代的垃圾收集， 速度比MinorGC慢10倍以上
		1. 目前只有CMS GC会单独收集老年代的行为
		2. 注意很多时候MajorGC和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。
	3. 混合收集（Mixed GC）收集整个新生代以及部分老年代的垃圾收集。
		1. 目前，只有G1 GC会有这种行为
2. 整堆收集（Full GC）收集整个Java堆和方法区的垃圾。

GC线程运行的时候，用户线程会受到干预从而停止运行，需要等GC线程收集回收完才进行重新开始运行，整个过程称之为STW(stop the work)

**触发FullGC的五种情况**
1. 调用System.gc(),系统建议执行FullGC,但不是必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过MinorGC进入老年代的平均大小大于老年代的可用内存
5. 由Eden区，survivor (from区)向（to区）复制时，对象大小大于to区可用内存，则把该对象转到老年代，且老年代的可用内存小于该对象大小

**说明**
full gc是开发或调优中尽量要避免的，这样暂停时间会短一些


## 6. 堆空间分代思想

为什么要把java堆分代？不分代就不能正常工作吗？
其实不分代完全可以，分代的唯一理由就是**优化GC性能**。如果没有分代，那所有对象都在一起。分析无用对象的时候就会进行全区域扫描，全区域扫描占用的时间会更长。如果是分代回收，就能减少不必要的扫描。从而达到优化GC性能的目的

	


## 7. 内存分配策略


内存分配策略又叫对象提升（Promotion）规则


晋升老年代的年龄阈值 可以用过选项 -XX:MaxTenuringThreshold=threshold 来设置】


针对不同年龄段的对象分配原则如下所示：
1. 优先分配到Eden
2. 大对象直接分配到老年代
	1. 尽量避免程序中出现过多的大对象（最好大对象的存活时间长!）
3. 长期存活的对象分配到老年代
4. 动态对象年龄判断
	1. 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
5. 空间分配担保(survivor区无法容纳的对象放在老年代)
	1. -XX:handlePromotionFailure






## 8. 为对象分配内存 TLAB

ThreadLocalAllocationBuffer
TLAB是为了解决多线程分配内存时可能存在冲突的问题


为什么有TLAB？ 
因为堆区是线程共享的，并发情况下线程不安全，如果要达到线程安全的目的就需要加锁，加锁就会影响程序执行效率


从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题
同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方法称为快速分配策略。

默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，
通过选项“-XX: TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。

可以jinfo -flag UseTLAB [PID] 查看是否开启TLAB

在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。



> TLAB分配过程
对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配

## 9. 小结堆空间的参数配置

-   -XX：+PrintFlagsInitial：查看所有的参数的默认初始值
-   -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
-   -Xms：初始堆空间内存（默认为物理内存的1/64）
-   -Xmx：最大堆空间内存（默认为物理内存的1/4）
-   -Xmn：设置新生代的大小。（初始值及最大值）（NewRatio会失效）
-   -XX:NewRatio：配置新生代与老年代在堆结构的占比
-   -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例
-   -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄
-   -XX：+PrintGCDetails：输出详细的GC处理日志
    -   打印gc简要信息：①-XX：+PrintGC ② - verbose:gc
-   -XX:HandlePromotionFalilure：是否设置空间分配担保

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

-   如果大于，则此次Minor GC是安全的
-   如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。
    -   如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
    -   如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
    -   如果小于，则改为进行一次FullGC。
    -   如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。

在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。**JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。**



## 10. 堆是分配对象的唯一选择吗？
随着JIT的发展，逃逸分析技术逐渐成熟。 带来了栈上分配，标量替换等优化技术
经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就会被优化升栈上分配。这样就无须在堆上分配内存，也无须进行垃圾回收。这也是最常见的对外存储技术

TaoBaoVM 创新了GCIH技术实现了off-heap，将生命周期较长的Java对象从heap中移至heap外，从而达到降低GC的回收频率。


### 逃逸分析？（Escape Analysis）
逃逸分析是为了优化 JVM 内存和提升程序性能的设计。

如果快速判断是否发生了逃逸分析，就看new的对象是否有可能在方法外被调用


### 什么是逃逸分析？

关于 Java 逃逸分析的定义：

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：

-   开启逃逸分析：-XX:+DoEscapeAnalysis
-   关闭逃逸分析：-XX:-DoEscapeAnalysis
-   显示分析结果：-XX:+PrintEscapeAnalysis

逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。


### 对象逃逸状态

1、全局逃逸（GlobalEscape）

即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

-   对象是一个静态变量
-   对象是一个已经发生逃逸的对象
-   对象作为当前方法的返回值

2、参数逃逸（ArgEscape）

即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。

3、没有逃逸

即方法中的对象没有发生逃逸。



### 逃逸分析优化

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。

#### 1) （同步省略）锁消除
我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。（如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步）
例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

换句话理解：
线程同步的代价是相当高的，同步的后果是降低并发性和性能。
在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。

锁消除的 JVM 参数如下：
-   开启锁消除：-XX:+EliminateLocks
-   关闭锁消除：-XX:-EliminateLocks
锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。



#### 2) 标量替换(分离对象)
首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。
对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。
这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下
-   开启标量替换：-XX:+EliminateAllocations
-   关闭标量替换：-XX:-EliminateAllocations
-   显示标量替换详情：-XX:+PrintEliminateAllocations
标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

总结就是： 把对象肢解成多个基本类型


#### 3) 栈上分配
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。


我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。



#### 结论

开发中能使用局部变量的，就不要使用在方法外定义。
使用逃逸分析，编译器可以对代码做如下优化：

-   栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配
-   同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
-   分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。