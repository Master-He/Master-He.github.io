**设计模式**

参考 

https://www.runoob.com/design-pattern/singleton-pattern.html

http://c.biancheng.net/view/1317.html

# UML图

连线种类

![image-20220515120559742](设计模式.assets/image-20220515120559742.png)

工具: 在线的presson， RationalRose,  IDEA的PlantUML插件

![image-20220515113204795](设计模式.assets/image-20220515113204795.png)

依赖是指，只要类中用到了对方，那么他们之间求存在依赖关系，比如B类的父类、成员变量、构造器参数、方法参数、返回值、是A类， B和A就存在依赖

关联只是， 类于类是1对1，1对多，多对1的关系， 比如B类有成员变量List\<A\>， B和A的关系就是1对多的关系

组合和聚合的异同点

​	相同点：都是整体和部分的关系，依赖关系为类和成员变量的关系
​	不同点：
​		组合关系，整体和部分不可以分开（比如人和人头）
​		聚合关系，整体和部分可以分开（比如人和身份证）

关联，聚合，组合，泛化，实现都是特殊情况的依赖

# 七大设计原则

设计原则核心思想

1. 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
3. 为了交互对象之间的松耦合设计而努力



七大设计原则 （开里单接依迪合）

1. 单一职责原则
    1. 一个类只干一件事，或者一个方法只干一件事。 比如做菜的活只让厨师干， 理发的活只让tony老师干
2. 接口隔离原则
    1. 一个类依赖的接口如果有他自己不需要的方法，那么就需要将这个接口进行拆分，拆分成几个接口，然后类只依赖自己需要的接口
    2. 接口隔离就是说依赖的接口必须是最小的接口，无关的接口要隔离掉
3. 依赖倒转原则
    1. 思想
        1. 高层模块不应该依赖底层模块，二者都应该依赖于其抽象
        2. 抽象不应该依赖于细节，细节应该依赖于抽象，这就是**反转**
        3. 依赖倒转（倒置）的中心思想是**面向接口编程**
        4. 依赖倒转的设计理念： 相对于细节的多变性，抽象的东西会更稳定，java中的抽象是接口和抽象类，细节是具体的实现类
        5. 使用接口和抽象类的目的是制定好规范，而不涉及任何的具体操作，展现细节的任务交给他们的实现类完成
    2. 实现方式
        1. 通过接口传递实现依赖
        2. 通过构造方法实现依赖
        3. 通过setter方法传递依赖
4. 里氏替换原则
    1. 思想
        1. 继承会增加对象间的耦合性
            1. 比如父类的修改会影响到子类，不然子类的功能可能会有故障。
            2. 去掉继承的做法：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，才用依赖，聚合，组合等关系替代
        2. 里氏替换原则
            1. **所有引用基类的地方必须能透明地使用其子类的对象**;  大白话就是父类被用到的地方，子类也能用，不会报错
            2. 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型
        3. 在子类中尽量不要重写父类的方法
            1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
            2. 如果要重写，覆盖或实现父类的方法时输入参数可以被放大
            3. 如果要从写，覆写或实现父类的方法时输出结果可以被缩小
        4. 参考 https://geek-docs.com/design-pattern/design-principle/liskov-substitution-principle.html
5. **开闭原则（核心，重点）**
    1. 一个软件实体如类，模块和函数应该对扩展开放(对提供方而言)，对修改关闭（对使用方而言）。用抽象构建矿建，用实现扩展细节
    2. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码的实现变化
6. 迪米特法则（最少知道原则）
    1. 一个对象应该对其他对象保持最少的了解
    2. 类与类的关系越密切，耦合度越大，耦合的方式有
        1. 依赖
        2. 关联
        3. 组合
        4. 聚合
    3. 迪米特法则还有个更简单的定义：只于直接的朋友通信， 直接的朋友包含
        1. 成员变量
        2. 方法参数
        3. 方法返回值
    4. 直接的朋友： 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之前是朋友关系，局部变量中的类不是直接的朋友，也就是说陌生的类不要以局部变量的形式出现在类的内部。
7. 合成复用原则
    1. 尽量使用依赖，组合，聚合的方式，而不是使用继承
       







# 设计模式（23种）

## github代码 

地址： https://github.com/Master-He/design-pattern/



## 创建型（5种）

创建型模式强调对象的创建， 在对象的创建上思考问题

### 工厂模式

1. 简单工厂模式（静态工厂模式）
2. 工厂方法模式

简单工厂不满足开闭原则， 而工厂方法模式满足



### 抽象工厂模式

和工厂模式的区别，工厂模式是针对一种产品的， 而抽象工厂模式是针对多种产品的，产品是一个系列或者有关系的
换句话说就是工厂模式生产一种产品，抽象工厂模式生产一整个产品族的产品

### 单例模式

1. 饿汉式
    1. 饿汉式（静态常量）--可用
2. 懒汉式
    1. 懒汉式（线程不安全）
    2. 懒汉式（线程安全， 同步方法）
    3. 懒汉式（线程安全，同步代码块）
3. 双重检查
4. 静态内部类
5. 枚举

### 原型模式

用于创建重复对象；如果直接创建对象过程比较复杂，比如创建过程需要连接数据库，那么可以通过复制创建新的对象
深拷贝的方法：	

1. 序列化和反序列化
2. 重写clone方法

### 建造者模式

建造者模式将对象和对象的创建过程解耦，方便构建复杂对象
建造者模式有四个部分，产品，抽象建造者，具体建造者，指挥者

隔离了复杂对象的创建和使用，并使相同的创建过程可以创建不同的产品
建造者侧重于一步步构建一个复杂的对象，构建完后返回。 侧重在于构建对象的步骤

建造者模式又叫生成器模式



## 结构型（7种）

结构型模式是站在软件结构上思考问题， 目的是从程序的结构上实现松耦合，从而可以扩大整体的类结构，解决更大的问题

### 适配器模式

适配器模式可以使**由于接口不兼容而不能一起工作的那些类**可以一起工作。比如Java代码中字节流转换成字符流就用到了此模式
简单的说就是原本不能兼容的类可以变得兼容

适配器的类型

1. 类适配器： 适配器继承被适配的类，实现要适配的接口
2. 对象适配器： 适配器聚合被适配的类，实现要适配的接口
3. 接口适配器：（接口隔离的一种实现方式）定义一个抽象类对接口进行空实现，然后继承抽象类只实现自己需要实现的方法。 这样就能达到只实现部分接口方法的目的

适配器模式使用案例： springmvc 的 dispatcher的HandleAdapter处理类



### 桥接模式

桥接将抽象部分和实现部分分离，使它们都可以独立的变化。 如果实现部分继承抽象部分，会造成类爆炸问题，扩展起来不灵活
比如抽象部分：电脑类型（平板电脑，笔记本电脑，台式电脑）实现部分：品牌（小米，华为，苹果， 三星），如果是实现部分继承抽象部分
就有3*4=12种类， 而如果是桥接则只有3+4=7种类，桥接不会有类爆炸问题，扩展起来也方便

桥接模式遵循了单一职责原则，一个类只做一件事

桥接模式是为了让类在多个维度上自由的扩展

桥接模式中， 抽象类（桥）是电脑， 抽象类的子类(平板，笔记本，台式) 通过电脑（桥）桥接到品牌接口，使用品牌的功能

```java
Computer抽象类（桥）
    Tablet平板电脑类 // 他可以通过桥调用Brand接口定义的方法
    Laptop笔记本电脑类
    Desktop台式电脑类
Brand接口（聚合到Computer类，作为Computer的成员变量）
    XiaoMi品牌
    Apple品牌
    HuaWei品牌
```

适配器模式使用案例：JDBC

桥接模式的优缺点

1. 优点
    1. 因为抽象和实现分离，极大提供了系统的灵活性。
    2. 桥接模式替代了多层继承方案，可以减少子类的个数，降低系统管理和维护成本。
2. 缺点
    1. 桥接模式的引入会增加系统的理解和设计的难度。因为聚合关联关系建立在抽象层，所以开发者需要针对抽象进行设计和编程
    2. 桥接模式需要正确识别说系统独立变化的维度，识别出哪个是抽象部分，哪个是实现部分

![image-20220522073846581](设计模式.assets/image-20220522073846581.png)



### **装饰器模式**

装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其原有的结构。即动态地将新功能附加到对象上

装饰器类 **继承 并 聚合** 了被装饰类， **聚合**会为了对类进行装饰，继承是为了装时候还是属于被装饰类

装饰器模式含有递归的思想

以快餐加配料为例

![image-20220522081819924](设计模式.assets/image-20220522081819924.png)

java IO源码就用到了装饰器模式



### 组合模式

组合模式又叫部分整体模式

组合模式  把一组相似对象当做单一对象，依据**树形结构**来组合对象

组合模式主要包含三种角色：

* 抽象根节点（Component）：定义系统**各层次对象**的共有方法和属性，可以预先定义一些**默认行为和属性。**
* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点**形成一个树形结构。**
* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。

在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为**透明组合模式**和**安全组合模式**两种形式。
透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法， 抽象根节点提供 add()、remove() 等方法对叶子结点是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错

java HashMap就用到了组合模式



### 外观模式

### 享元模式



### **代理模式**

代理模式分为

- 静态代理
- 动态代理
    - JDK代理
        - JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。
    - CGLib代理
        - 需要引入第三方包
        - spring AOP用的是cglib代理

结构

​	代理（Proxy）模式分为三种角色：

* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。
* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。



代理选择

* jdk代理和CGLIB代理

    使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。

    在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。

* 动态代理和静态代理

    动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。

    如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题



## 行为型（11种）

在方法的设计层面上思考问题

### 模板方法模式

### 命令模式

### 访问者模式

### 迭代器模式

### 观察者模式

### 中介者模式

### 备忘录模式

### 解释器模式

### 状态模式

### 策略模式

### 责任链模式